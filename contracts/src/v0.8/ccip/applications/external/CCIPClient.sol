// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {IRouterClient} from "../../interfaces/IRouterClient.sol";

import {Client} from "../../libraries/Client.sol";
import {CCIPReceiver} from "./CCIPReceiver.sol";

import {IERC20} from "../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title CCIPClient
/// @notice This contract implements logic for sending and receiving CCIP Messages. It utilizes CCIPReceiver's defensive patterns by default.
/// @dev CCIPReceiver and CCIPSender cannot be simultaneously imported due to similar parents so CCIPSender functionality has been duplicated
contract CCIPClient is CCIPReceiver {
  using SafeERC20 for IERC20;

  event MessageSent(bytes32 messageId);
  event FeeTokenUpdated(address oldFeeToken, address newFeeToken);

  IERC20 internal s_feeToken;
  bool internal immutable i_isPreFunded;

  /// @dev A check for the zero-address is not explicitly performed since it is included in the CCIPBase parent constructor
  /// @param feeToken An ERC20-compatible token, address(0) if fees should be paid in native tokens instead.
  constructor(address router, IERC20 feeToken, bool usePreFunding) CCIPReceiver(router) {
    s_feeToken = feeToken;
    i_isPreFunded = usePreFunding;

    if (address(feeToken) != address(0)) {
      IERC20(feeToken).safeApprove(s_ccipRouter, type(uint256).max);
    }
  }

  /// @notice sends a message through CCIP to the router
  /// @param destChainSelector The unique CCIP identifier for a destination chain
  /// @param tokenAmounts An array of CCIP compatible tokens and their amounts to send through the bridge
  /// @param data Arbitrary bytes to be sent to the destination address on the destination chain
  /// @dev The recipient of the message and any extraArgs are set manually ahead of time using the applyChainUpdates() function in CCIPBase
  /// @return messageId the unique message ID generated by the CCIP router and used to track message status.
  function ccipSend(
    uint64 destChainSelector,
    Client.EVMTokenAmount[] memory tokenAmounts,
    bytes memory data
  ) public payable virtual isValidChain(destChainSelector) returns (bytes32 messageId) {
    Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
      receiver: s_chainConfigs[destChainSelector].recipient,
      data: data,
      tokenAmounts: tokenAmounts,
      extraArgs: s_chainConfigs[destChainSelector].extraArgsBytes,
      feeToken: address(s_feeToken)
    });

    uint256 fee = IRouterClient(s_ccipRouter).getFee(destChainSelector, message);

    if (!usePreFundedFeeTokens() && address(s_feeToken) != address(0)) {
      IERC20(s_feeToken).safeTransferFrom(msg.sender, address(this), fee);
    }

    for (uint256 i = 0; i < tokenAmounts.length; ++i) {
      // Transfer the tokens specified in TokenAmounts[] so that it can be forwarded to the router
      IERC20(tokenAmounts[i].token).safeTransferFrom(msg.sender, address(this), tokenAmounts[i].amount);

      // Do not approve the tokens if it is the feeToken, otherwise the approval amount may overflow
      if (tokenAmounts[i].token != address(s_feeToken)) {
        IERC20(tokenAmounts[i].token).safeApprove(s_ccipRouter, tokenAmounts[i].amount);
      }
    }

    // messageId is only generated in the on-ramp, and therefore cannot be calculated head of time.
    // This necessitates breaking CEI but since the router is a trusted contract, any risks are negligible.
    messageId = IRouterClient(s_ccipRouter).ccipSend{value: address(s_feeToken) == address(0) ? fee : 0}(
      destChainSelector, message
    );

    emit MessageSent(messageId);

    return messageId;
  }

  /// @notice Update the address of the token used to pay for CCIP fees.
  /// @param token the token address, the zero address should be used if fees should be paid with native tokens
  function updateFeeToken(address token) external onlyOwner {
    // If the current fee token is not-native, zero out the allowance to the router for safety
    if (address(s_feeToken) != address(0)) {
      s_feeToken.safeApprove(getRouter(), 0);
    }

    address oldFeeToken = address(s_feeToken);
    s_feeToken = IERC20(token);

    // Approve the router to spend the new fee token
    if (token != address(0)) {
      s_feeToken.safeIncreaseAllowance(getRouter(), type(uint256).max);
    }

    emit FeeTokenUpdated(oldFeeToken, token);
  }

  /// @notice Whether or not the contract should use funds already in its posesssion to pay CCIP fees, or to
  /// transfer the necessary tokens from the msg.sender
  /// @return isPreFunded Returns true if fees should be paid with pre funded tokens
  function usePreFundedFeeTokens() public view virtual returns (bool isPreFunded) {
    return i_isPreFunded;
  }

  /// @notice Retrieve the address of the fee token to be used in ccipSend()
  /// @return feeToken the address of the token used to pay fees. The zero address indicates native-tokens
  function getFeeToken() public view virtual returns (address feeToken) {
    return address(s_feeToken);
  }
}
