// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {IRouterClient} from "../../interfaces/IRouterClient.sol";
import {Client} from "../../libraries/Client.sol";
import {CCIPReceiverWithACK} from "./CCIPReceiverWithACK.sol";

import {IERC20} from "../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title CCIPClientWithACK
/// @notice This contract implements logic for sending and receiving CCIP Messages, as well as responding to incoming messages with an ACK-response pattern. It utilizes CCIPReceiver's defensive patterns by default.
/// @dev ccipSend functionality has been inherited from CCIPClient.sol, and _sendACK() from CCIPReceiverWithACK, so only processMessage() must be overridden to enable full functionality for processing incoming messages for ACK's
contract CCIPClientWithACK is CCIPReceiverWithACK {
  using SafeERC20 for IERC20;

  error CannotAcknowledgeUnsentMessage(bytes32);

  constructor(address router, IERC20 feeToken) CCIPReceiverWithACK(router, feeToken) {}

  /// @notice sends a message through CCIP to the router
  /// @param destChainSelector The unique CCIP identifier for a destination chain
  /// @param tokenAmounts An array of CCIP compatible tokens and their amounts to send through the bridge
  /// @param data Arbitrary bytes to be sent to the destination address on the destination chain
  /// @dev The recipient of the message and any extraArgs are set manually ahead of time using the applyChainUpdates() function in CCIPBase
  /// @return messageId the unique message ID generated by the CCIP router and used to track message status.
  function ccipSend(
    uint64 destChainSelector,
    Client.EVMTokenAmount[] memory tokenAmounts,
    bytes memory data
  ) public payable virtual isValidChain(destChainSelector) returns (bytes32 messageId) {
    Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
      receiver: s_chainConfigs[destChainSelector].recipient,
      data: data,
      tokenAmounts: tokenAmounts,
      extraArgs: s_chainConfigs[destChainSelector].extraArgsBytes,
      feeToken: address(s_feeToken)
    });

    for (uint256 i = 0; i < tokenAmounts.length; ++i) {
      // Transfer the tokens to pay for tokens in tokenAmounts
      IERC20(tokenAmounts[i].token).safeTransferFrom(msg.sender, address(this), tokenAmounts[i].amount);

      // Do not approve the tokens if it is the feeToken, otherwise the approval amount may overflow
      if (tokenAmounts[i].token != address(s_feeToken)) {
        IERC20(tokenAmounts[i].token).safeApprove(s_ccipRouter, tokenAmounts[i].amount);
      }
    }

    uint256 fee = IRouterClient(s_ccipRouter).getFee(destChainSelector, message);

    // Additional tokens for fees do not need to be approved to the router since it is already handled by setting s_feeToken
    if (address(s_feeToken) != address(0)) {
      IERC20(s_feeToken).safeTransferFrom(msg.sender, address(this), fee);
    }

    messageId = IRouterClient(s_ccipRouter).ccipSend{value: address(s_feeToken) == address(0) ? fee : 0}(
      destChainSelector, message
    );

    s_messageStatus[messageId] = CCIPReceiverWithACK.MessageStatus.SENT;

    emit MessageSent(messageId, bytes32(0));

    return messageId;
  }

  /// @notice Implementation of arbitrary logic to be executed when a CCIP message is received
  /// @dev is only invoked by self on CCIPReceive, and should implement arbitrary dapp-specific logic
  function processMessage(Client.Any2EVMMessage calldata message)
    external
    virtual
    override
    onlySelf
    isValidSender(message.sourceChainSelector, message.sender)
  {
    (MessagePayload memory payload) = abi.decode(message.data, (MessagePayload));

    if (payload.messageType == MessageType.OUTGOING) {
      // Insert Processing workflow here.

      // If the message was outgoing, then send an ack response.
      _sendAck(message);
    } else if (payload.messageType == MessageType.ACK) {
      // Decode message into the message-header and the messageId to ensure the message is encoded correctly
      (string memory messageHeader, bytes32 messageId) = abi.decode(payload.data, (string, bytes32));

      // Ensure Ack Message contains proper message header
      if (keccak256(abi.encode(messageHeader)) != keccak256(abi.encode(ACK_MESSAGE_HEADER))) {
        revert InvalidAckMessageHeader();
      }

      // Make sure the ACK message was originally sent by this contract
      if (s_messageStatus[messageId] != MessageStatus.SENT) revert CannotAcknowledgeUnsentMessage(messageId);

      // Mark the message has finalized from a proper ack-message.
      s_messageStatus[messageId] = MessageStatus.ACKNOWLEDGED;

      emit MessageAckReceived(messageId);
    }
  }
}
