// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package rbactimelock

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// RBACTimelockCall is an auto generated low-level Go binding around an user-defined struct.
type RBACTimelockCall struct {
	Target common.Address
	Value  *big.Int
	Data   []byte
}

// RbactimelockMetaData contains all meta data concerning the Rbactimelock contract.
var RbactimelockMetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"minDelay\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"admin\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"proposers\",\"type\":\"address[]\",\"internalType\":\"address[]\"},{\"name\":\"executors\",\"type\":\"address[]\",\"internalType\":\"address[]\"},{\"name\":\"cancellers\",\"type\":\"address[]\",\"internalType\":\"address[]\"},{\"name\":\"bypassers\",\"type\":\"address[]\",\"internalType\":\"address[]\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"receive\",\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"ADMIN_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"BYPASSER_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"CANCELLER_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"DEFAULT_ADMIN_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"EXECUTOR_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"PROPOSER_ROLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"blockFunctionSelector\",\"inputs\":[{\"name\":\"selector\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"bypasserExecuteBatch\",\"inputs\":[{\"name\":\"calls\",\"type\":\"tuple[]\",\"internalType\":\"structRBACTimelock.Call[]\",\"components\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"internalType\":\"bytes\"}]}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"executeBatch\",\"inputs\":[{\"name\":\"calls\",\"type\":\"tuple[]\",\"internalType\":\"structRBACTimelock.Call[]\",\"components\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"internalType\":\"bytes\"}]},{\"name\":\"predecessor\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"salt\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"getBlockedFunctionSelectorAt\",\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getBlockedFunctionSelectorCount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getMinDelay\",\"inputs\":[],\"outputs\":[{\"name\":\"duration\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getRoleAdmin\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getRoleMember\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getRoleMemberCount\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getTimestamp\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"grantRole\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"hasRole\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"hashOperationBatch\",\"inputs\":[{\"name\":\"calls\",\"type\":\"tuple[]\",\"internalType\":\"structRBACTimelock.Call[]\",\"components\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"internalType\":\"bytes\"}]},{\"name\":\"predecessor\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"salt\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"pure\"},{\"type\":\"function\",\"name\":\"isOperation\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"registered\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"isOperationDone\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"done\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"isOperationPending\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"pending\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"isOperationReady\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[{\"name\":\"ready\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"onERC1155BatchReceived\",\"inputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"uint256[]\",\"internalType\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\",\"internalType\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"onERC1155Received\",\"inputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"onERC721Received\",\"inputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"renounceRole\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"revokeRole\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"scheduleBatch\",\"inputs\":[{\"name\":\"calls\",\"type\":\"tuple[]\",\"internalType\":\"structRBACTimelock.Call[]\",\"components\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"internalType\":\"bytes\"}]},{\"name\":\"predecessor\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"salt\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"delay\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"unblockFunctionSelector\",\"inputs\":[{\"name\":\"selector\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"updateDelay\",\"inputs\":[{\"name\":\"newDelay\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"event\",\"name\":\"BypasserCallExecuted\",\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\",\"indexed\":true,\"internalType\":\"uint256\"},{\"name\":\"target\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"CallExecuted\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\",\"indexed\":true,\"internalType\":\"uint256\"},{\"name\":\"target\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"CallScheduled\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\",\"indexed\":true,\"internalType\":\"uint256\"},{\"name\":\"target\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"predecessor\",\"type\":\"bytes32\",\"indexed\":false,\"internalType\":\"bytes32\"},{\"name\":\"salt\",\"type\":\"bytes32\",\"indexed\":false,\"internalType\":\"bytes32\"},{\"name\":\"delay\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Cancelled\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"FunctionSelectorBlocked\",\"inputs\":[{\"name\":\"selector\",\"type\":\"bytes4\",\"indexed\":true,\"internalType\":\"bytes4\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"FunctionSelectorUnblocked\",\"inputs\":[{\"name\":\"selector\",\"type\":\"bytes4\",\"indexed\":true,\"internalType\":\"bytes4\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MinDelayChange\",\"inputs\":[{\"name\":\"oldDuration\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"newDuration\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RoleAdminChanged\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"previousAdminRole\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"newAdminRole\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RoleGranted\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RoleRevoked\",\"inputs\":[{\"name\":\"role\",\"type\":\"bytes32\",\"indexed\":true,\"internalType\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false}]",
	Bin: "0x60806040523480156200001157600080fd5b50604051620027bc380380620027bc833981016040819052620000349162000533565b6200004f6000805160206200277c83398151915280620002bb565b620000796000805160206200273c8339815191526000805160206200277c833981519152620002bb565b620000a36000805160206200275c8339815191526000805160206200277c833981519152620002bb565b620000cd6000805160206200279c8339815191526000805160206200277c833981519152620002bb565b620001087fa1b2b8005de234c4b8ce8cd0be058239056e0d54f6097825b5117101469d5a8d6000805160206200277c833981519152620002bb565b620001236000805160206200277c8339815191528662000306565b60005b845181101562000180576200016d6000805160206200273c83398151915286838151811062000159576200015962000608565b60200260200101516200030660201b60201c565b62000178816200061e565b905062000126565b5060005b8351811015620001ca57620001b76000805160206200275c83398151915285838151811062000159576200015962000608565b620001c2816200061e565b905062000184565b5060005b82518110156200021457620002016000805160206200279c83398151915284838151811062000159576200015962000608565b6200020c816200061e565b9050620001ce565b5060005b81518110156200026f576200025c7fa1b2b8005de234c4b8ce8cd0be058239056e0d54f6097825b5117101469d5a8d83838151811062000159576200015962000608565b62000267816200061e565b905062000218565b5060038690556040805160008152602081018890527f11c24f4ead16507c69ac467fbd5e4eed5fb5c699626d2cc6d66421df253886d5910160405180910390a150505050505062000646565b600082815260208190526040808220600101805490849055905190918391839186917fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff9190a4505050565b62000312828262000316565b5050565b62000322828262000341565b60008281526001602052604090206200033c9082620003e1565b505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000312576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556200039d3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620003f8836001600160a01b03841662000401565b90505b92915050565b60008181526001830160205260408120546200044a57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620003fb565b506000620003fb565b80516001600160a01b03811681146200046b57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200049857600080fd5b815160206001600160401b0380831115620004b757620004b762000470565b8260051b604051601f19603f83011681018181108482111715620004df57620004df62000470565b604052938452858101830193838101925087851115620004fe57600080fd5b83870191505b848210156200052857620005188262000453565b8352918301919083019062000504565b979650505050505050565b60008060008060008060c087890312156200054d57600080fd5b865195506200055f6020880162000453565b60408801519095506001600160401b03808211156200057d57600080fd5b6200058b8a838b0162000486565b95506060890151915080821115620005a257600080fd5b620005b08a838b0162000486565b94506080890151915080821115620005c757600080fd5b620005d58a838b0162000486565b935060a0890151915080821115620005ec57600080fd5b50620005fb89828a0162000486565b9150509295509295509295565b634e487b7160e01b600052603260045260246000fd5b6000600182016200063f57634e487b7160e01b600052601160045260246000fd5b5060010190565b6120e680620006566000396000f3fe6080604052600436106101f25760003560e01c806364d623531161010d578063a944142d116100a0578063ca15c8731161006f578063ca15c8731461062d578063d45c44351461064d578063d547741f1461067a578063f23a6e611461069a578063f27a0c92146106c657600080fd5b8063a944142d1461058d578063b08e51c0146105ad578063bc197c81146105e1578063c4d252f51461060d57600080fd5b80639010d07c116100dc5780639010d07c1461050057806391d14854146105385780639f5a23f714610558578063a217fddf1461057857600080fd5b806364d62353146104775780636ceef4801461049757806375b238fc146104aa5780638f61f4f5146104cc57600080fd5b806326bb2ec51161018557806336568abe1161015457806336568abe146103f75780633a98b4e414610417578063515a3db314610437578063584b153e1461045757600080fd5b806326bb2ec5146103725780632ab0f529146103875780632f2ff15d146103b757806331d50750146103d757600080fd5b806313bc9f20116101c157806313bc9f20146102c3578063150b7a02146102e3578063191cb7b31461030e578063248a9ca31461034257600080fd5b806301ffc9a7146101fe57806303e561551461023357806307bd02651461026c5780630db866b1146102ae57600080fd5b366101f957005b600080fd5b34801561020a57600080fd5b5061021e6102193660046117d2565b6106db565b60405190151581526020015b60405180910390f35b34801561023f57600080fd5b5061025361024e3660046117fc565b610706565b6040516001600160e01b0319909116815260200161022a565b34801561027857600080fd5b506102a07fd8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e6381565b60405190815260200161022a565b6102c16102bc366004611860565b610713565b005b3480156102cf57600080fd5b5061021e6102de3660046117fc565b61086f565b3480156102ef57600080fd5b506102536102fe366004611972565b630a85bd0160e11b949350505050565b34801561031a57600080fd5b506102a07fa1b2b8005de234c4b8ce8cd0be058239056e0d54f6097825b5117101469d5a8d81565b34801561034e57600080fd5b506102a061035d3660046117fc565b60009081526020819052604090206001015490565b34801561037e57600080fd5b506102a0610895565b34801561039357600080fd5b5061021e6103a23660046117fc565b60009081526002602052604090205460011490565b3480156103c357600080fd5b506102c16103d23660046119d9565b6108a6565b3480156103e357600080fd5b5061021e6103f23660046117fc565b6108d0565b34801561040357600080fd5b506102c16104123660046119d9565b6108e9565b34801561042357600080fd5b506102c16104323660046117d2565b61096c565b34801561044357600080fd5b506102a0610452366004611a05565b6109d7565b34801561046357600080fd5b5061021e6104723660046117fc565b610a10565b34801561048357600080fd5b506102c16104923660046117fc565b610a27565b6102c16104a5366004611a05565b610a81565b3480156104b657600080fd5b506102a060008051602061209183398151915281565b3480156104d857600080fd5b506102a07fb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc181565b34801561050c57600080fd5b5061052061051b366004611a55565b610bed565b6040516001600160a01b03909116815260200161022a565b34801561054457600080fd5b5061021e6105533660046119d9565b610c05565b34801561056457600080fd5b506102c16105733660046117d2565b610c2e565b34801561058457600080fd5b506102a0600081565b34801561059957600080fd5b506102c16105a8366004611a77565b610c99565b3480156105b957600080fd5b506102a07ffd643c72710c63c0180259aba6b2d05451e3591a24e58b62239378085726f78381565b3480156105ed57600080fd5b506102536105fc366004611b4f565b63bc197c8160e01b95945050505050565b34801561061957600080fd5b506102c16106283660046117fc565b610e28565b34801561063957600080fd5b506102a06106483660046117fc565b610f16565b34801561065957600080fd5b506102a06106683660046117fc565b60009081526002602052604090205490565b34801561068657600080fd5b506102c16106953660046119d9565b610f2d565b3480156106a657600080fd5b506102536106b5366004611bf8565b63f23a6e6160e01b95945050505050565b3480156106d257600080fd5b506003546102a0565b60006001600160e01b03198216630271189760e51b1480610700575061070082610f52565b92915050565b6000610700600483610f77565b7fa1b2b8005de234c4b8ce8cd0be058239056e0d54f6097825b5117101469d5a8d3361074d60008051602061209183398151915282610c05565b61075b5761075b8282610f83565b60005b838110156108685761079285858381811061077b5761077b611c5c565b905060200281019061078d9190611c72565b610fdc565b807f6b983f337bab73dfe37faca733adf3ea35b45b8b144ec8ee2de3a1b224564b0c8686848181106107c6576107c6611c5c565b90506020028101906107d89190611c72565b6107e6906020810190611c92565b8787858181106107f8576107f8611c5c565b905060200281019061080a9190611c72565b6020013588888681811061082057610820611c5c565b90506020028101906108329190611c72565b610840906040810190611cad565b6040516108509493929190611d1c565b60405180910390a261086181611d64565b905061075e565b5050505050565b60008181526002602052604081205460018111801561088e5750428111155b9392505050565b60006108a160046110bd565b905090565b6000828152602081905260409020600101546108c1816110c7565b6108cb83836110d4565b505050565b60008181526002602052604081205481905b1192915050565b6001600160a01b038116331461095e5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b61096882826110f6565b5050565b600080516020612091833981519152610984816110c7565b61099960046001600160e01b03198416611118565b15610968576040516001600160e01b03198316907fd91859a8d88193a56a2983deb65a5253985141c49c70bf016880b5243bd432e190600090a25050565b6000848484846040516020016109f09493929190611d7d565b604051602081830303815290604052805190602001209050949350505050565b6000818152600260205260408120546001906108e2565b600080516020612091833981519152610a3f816110c7565b60035460408051918252602082018490527f11c24f4ead16507c69ac467fbd5e4eed5fb5c699626d2cc6d66421df253886d5910160405180910390a150600355565b7fd8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e6333610abb60008051602061209183398151915282610c05565b610ac957610ac98282610f83565b6000610ad7878787876109d7565b9050610ae38186611124565b60005b86811015610bda57610b0388888381811061077b5761077b611c5c565b80827fc2617efa69bab66782fa219543714338489c4e9e178271560a91b82c3f612b588a8a85818110610b3857610b38611c5c565b9050602002810190610b4a9190611c72565b610b58906020810190611c92565b8b8b86818110610b6a57610b6a611c5c565b9050602002810190610b7c9190611c72565b602001358c8c87818110610b9257610b92611c5c565b9050602002810190610ba49190611c72565b610bb2906040810190611cad565b604051610bc29493929190611d1c565b60405180910390a3610bd381611d64565b9050610ae6565b50610be4816111b0565b50505050505050565b600082815260016020526040812061088e9083610f77565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b600080516020612091833981519152610c46816110c7565b610c5b60046001600160e01b031984166111e9565b15610968576040516001600160e01b03198316907f15b40cf8ed4c95cd3c0e1dedfdb3987c3f9bf3d3770d13ddf6dc4daa5ffae9ef90600090a25050565b7fb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc133610cd360008051602061209183398151915282610c05565b610ce157610ce18282610f83565b6000610cef888888886109d7565b9050610cfb81856111f5565b60005b87811015610e1d57610d40898983818110610d1b57610d1b611c5c565b9050602002810190610d2d9190611c72565b610d3b906040810190611cad565b6112cf565b80827f4f4da6666f52e3b6dbc3638d8eae4017722678fe58bca79cd8320817807a65be8b8b85818110610d7557610d75611c5c565b9050602002810190610d879190611c72565b610d95906020810190611c92565b8c8c86818110610da757610da7611c5c565b9050602002810190610db99190611c72565b602001358d8d87818110610dcf57610dcf611c5c565b9050602002810190610de19190611c72565b610def906040810190611cad565b8d8d8d604051610e059796959493929190611e65565b60405180910390a3610e1681611d64565b9050610cfe565b505050505050505050565b7ffd643c72710c63c0180259aba6b2d05451e3591a24e58b62239378085726f78333610e6260008051602061209183398151915282610c05565b610e7057610e708282610f83565b610e7983610a10565b610ed95760405162461bcd60e51b815260206004820152602b60248201527f5242414354696d656c6f636b3a206f7065726174696f6e2063616e6e6f74206260448201526a194818d85b98d95b1b195960aa1b6064820152608401610955565b6000838152600260205260408082208290555184917fbaa1eb22f2a492ba1a5fea61b8df4d27c6c8b5f3971e63bb58fa14ff72eedb7091a2505050565b6000818152600160205260408120610700906110bd565b600082815260208190526040902060010154610f48816110c7565b6108cb83836110f6565b60006001600160e01b03198216635a05180f60e01b1480610700575061070082611375565b600061088e83836113aa565b610f8d8282610c05565b61096857610f9a816113d4565b610fa58360206113e6565b604051602001610fb6929190611ed0565b60408051601f198184030181529082905262461bcd60e51b825261095591600401611f45565b6000610feb6020830183611c92565b6001600160a01b031660208301356110066040850185611cad565b604051611014929190611f78565b60006040518083038185875af1925050503d8060008114611051576040519150601f19603f3d011682016040523d82523d6000602084013e611056565b606091505b50509050806109685760405162461bcd60e51b815260206004820152602d60248201527f5242414354696d656c6f636b3a20756e6465726c79696e67207472616e73616360448201526c1d1a5bdb881c995d995c9d1959609a1b6064820152608401610955565b6000610700825490565b6110d18133610f83565b50565b6110de8282611581565b60008281526001602052604090206108cb9082611605565b611100828261161a565b60008281526001602052604090206108cb908261167f565b600061088e8383611690565b61112d8261086f565b6111495760405162461bcd60e51b815260040161095590611f88565b80158061116457506000818152600260205260409020546001145b6109685760405162461bcd60e51b815260206004820181905260248201527f5242414354696d656c6f636b3a206d697373696e6720646570656e64656e63796044820152606401610955565b6111b98161086f565b6111d55760405162461bcd60e51b815260040161095590611f88565b600090815260026020526040902060019055565b600061088e8383611783565b6111fe826108d0565b1561125d5760405162461bcd60e51b815260206004820152602960248201527f5242414354696d656c6f636b3a206f7065726174696f6e20616c7265616479206044820152681cd8da19591d5b195960ba1b6064820152608401610955565b6003548110156112af5760405162461bcd60e51b815260206004820181905260248201527f5242414354696d656c6f636b3a20696e73756666696369656e742064656c61796044820152606401610955565b6112b98142611fcc565b6000928352600260205260409092209190915550565b60048110156112dc575050565b60006112eb6004828486611fdf565b6112f491612009565b905061131e60046001600160e01b031983166000818152600183016020526040812054151561088e565b156108cb5760405162461bcd60e51b815260206004820152602160248201527f5242414354696d656c6f636b3a2073656c6563746f7220697320626c6f636b656044820152601960fa1b6064820152608401610955565b60006001600160e01b03198216637965db0b60e01b148061070057506301ffc9a760e01b6001600160e01b0319831614610700565b60008260000182815481106113c1576113c1611c5c565b9060005260206000200154905092915050565b60606107006001600160a01b03831660145b606060006113f5836002612039565b611400906002611fcc565b6001600160401b03811115611417576114176118bd565b6040519080825280601f01601f191660200182016040528015611441576020820181803683370190505b509050600360fc1b8160008151811061145c5761145c611c5c565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061148b5761148b611c5c565b60200101906001600160f81b031916908160001a90535060006114af846002612039565b6114ba906001611fcc565b90505b6001811115611532576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106114ee576114ee611c5c565b1a60f81b82828151811061150457611504611c5c565b60200101906001600160f81b031916908160001a90535060049490941c9361152b81612050565b90506114bd565b50831561088e5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610955565b61158b8282610c05565b610968576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556115c13390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600061088e836001600160a01b038416611783565b6116248282610c05565b15610968576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600061088e836001600160a01b0384165b600081815260018301602052604081205480156117795760006116b4600183612067565b85549091506000906116c890600190612067565b905081811461172d5760008660000182815481106116e8576116e8611c5c565b906000526020600020015490508087600001848154811061170b5761170b611c5c565b6000918252602080832090910192909255918252600188019052604090208390555b855486908061173e5761173e61207a565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610700565b6000915050610700565b60008181526001830160205260408120546117ca57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610700565b506000610700565b6000602082840312156117e457600080fd5b81356001600160e01b03198116811461088e57600080fd5b60006020828403121561180e57600080fd5b5035919050565b60008083601f84011261182757600080fd5b5081356001600160401b0381111561183e57600080fd5b6020830191508360208260051b850101111561185957600080fd5b9250929050565b6000806020838503121561187357600080fd5b82356001600160401b0381111561188957600080fd5b61189585828601611815565b90969095509350505050565b80356001600160a01b03811681146118b857600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156118fb576118fb6118bd565b604052919050565b600082601f83011261191457600080fd5b81356001600160401b0381111561192d5761192d6118bd565b611940601f8201601f19166020016118d3565b81815284602083860101111561195557600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806080858703121561198857600080fd5b611991856118a1565b935061199f602086016118a1565b92506040850135915060608501356001600160401b038111156119c157600080fd5b6119cd87828801611903565b91505092959194509250565b600080604083850312156119ec57600080fd5b823591506119fc602084016118a1565b90509250929050565b60008060008060608587031215611a1b57600080fd5b84356001600160401b03811115611a3157600080fd5b611a3d87828801611815565b90989097506020870135966040013595509350505050565b60008060408385031215611a6857600080fd5b50508035926020909101359150565b600080600080600060808688031215611a8f57600080fd5b85356001600160401b03811115611aa557600080fd5b611ab188828901611815565b9099909850602088013597604081013597506060013595509350505050565b600082601f830112611ae157600080fd5b813560206001600160401b03821115611afc57611afc6118bd565b8160051b611b0b8282016118d3565b9283528481018201928281019087851115611b2557600080fd5b83870192505b84831015611b4457823582529183019190830190611b2b565b979650505050505050565b600080600080600060a08688031215611b6757600080fd5b611b70866118a1565b9450611b7e602087016118a1565b935060408601356001600160401b0380821115611b9a57600080fd5b611ba689838a01611ad0565b94506060880135915080821115611bbc57600080fd5b611bc889838a01611ad0565b93506080880135915080821115611bde57600080fd5b50611beb88828901611903565b9150509295509295909350565b600080600080600060a08688031215611c1057600080fd5b611c19866118a1565b9450611c27602087016118a1565b9350604086013592506060860135915060808601356001600160401b03811115611c5057600080fd5b611beb88828901611903565b634e487b7160e01b600052603260045260246000fd5b60008235605e19833603018112611c8857600080fd5b9190910192915050565b600060208284031215611ca457600080fd5b61088e826118a1565b6000808335601e19843603018112611cc457600080fd5b8301803591506001600160401b03821115611cde57600080fd5b60200191503681900382131561185957600080fd5b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60018060a01b0385168152836020820152606060408201526000611d44606083018486611cf3565b9695505050505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611d7657611d76611d4e565b5060010190565b60608082528181018590526000906080600587901b8401810190840188845b89811015611e4e57868403607f190183528135368c9003605e19018112611dc257600080fd5b8b016001600160a01b03611dd5826118a1565b16855260208082013581870152604080830135601e19843603018112611dfa57600080fd5b9092018181019290356001600160401b03811115611e1757600080fd5b803603841315611e2657600080fd5b8882890152611e388989018286611cf3565b9750505093840193929092019150600101611d9c565b505050602084019590955250506040015292915050565b60018060a01b038816815286602082015260c060408201526000611e8d60c083018789611cf3565b606083019590955250608081019290925260a090910152949350505050565b60005b83811015611ec7578181015183820152602001611eaf565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611f08816017850160208801611eac565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351611f39816028840160208801611eac565b01602801949350505050565b6020815260008251806020840152611f64816040850160208701611eac565b601f01601f19169190910160400192915050565b8183823760009101908152919050565b60208082526024908201527f5242414354696d656c6f636b3a206f7065726174696f6e206973206e6f7420726040820152636561647960e01b606082015260800190565b8082018082111561070057610700611d4e565b60008085851115611fef57600080fd5b83861115611ffc57600080fd5b5050820193919092039150565b6001600160e01b031981358181169160048510156120315780818660040360031b1b83161692505b505092915050565b808202811582820484141761070057610700611d4e565b60008161205f5761205f611d4e565b506000190190565b8181038181111561070057610700611d4e565b634e487b7160e01b600052603160045260246000fdfea49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775a264697066735822122064a83f60721959359d1c432c52a08f81bea2667aebccbbc732918f7169a85df564736f6c63430008130033b09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1d8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e63a49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775fd643c72710c63c0180259aba6b2d05451e3591a24e58b62239378085726f783",
}

// RbactimelockABI is the input ABI used to generate the binding from.
// Deprecated: Use RbactimelockMetaData.ABI instead.
var RbactimelockABI = RbactimelockMetaData.ABI

// RbactimelockBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use RbactimelockMetaData.Bin instead.
var RbactimelockBin = RbactimelockMetaData.Bin

// DeployRbactimelock deploys a new Ethereum contract, binding an instance of Rbactimelock to it.
func DeployRbactimelock(auth *bind.TransactOpts, backend bind.ContractBackend, minDelay *big.Int, admin common.Address, proposers []common.Address, executors []common.Address, cancellers []common.Address, bypassers []common.Address) (common.Address, *types.Transaction, *Rbactimelock, error) {
	parsed, err := RbactimelockMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(RbactimelockBin), backend, minDelay, admin, proposers, executors, cancellers, bypassers)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Rbactimelock{RbactimelockCaller: RbactimelockCaller{contract: contract}, RbactimelockTransactor: RbactimelockTransactor{contract: contract}, RbactimelockFilterer: RbactimelockFilterer{contract: contract}}, nil
}

// Rbactimelock is an auto generated Go binding around an Ethereum contract.
type Rbactimelock struct {
	RbactimelockCaller     // Read-only binding to the contract
	RbactimelockTransactor // Write-only binding to the contract
	RbactimelockFilterer   // Log filterer for contract events
}

// RbactimelockCaller is an auto generated read-only Go binding around an Ethereum contract.
type RbactimelockCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RbactimelockTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RbactimelockTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RbactimelockFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RbactimelockFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RbactimelockSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RbactimelockSession struct {
	Contract     *Rbactimelock     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RbactimelockCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RbactimelockCallerSession struct {
	Contract *RbactimelockCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// RbactimelockTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RbactimelockTransactorSession struct {
	Contract     *RbactimelockTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// RbactimelockRaw is an auto generated low-level Go binding around an Ethereum contract.
type RbactimelockRaw struct {
	Contract *Rbactimelock // Generic contract binding to access the raw methods on
}

// RbactimelockCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RbactimelockCallerRaw struct {
	Contract *RbactimelockCaller // Generic read-only contract binding to access the raw methods on
}

// RbactimelockTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RbactimelockTransactorRaw struct {
	Contract *RbactimelockTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRbactimelock creates a new instance of Rbactimelock, bound to a specific deployed contract.
func NewRbactimelock(address common.Address, backend bind.ContractBackend) (*Rbactimelock, error) {
	contract, err := bindRbactimelock(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Rbactimelock{RbactimelockCaller: RbactimelockCaller{contract: contract}, RbactimelockTransactor: RbactimelockTransactor{contract: contract}, RbactimelockFilterer: RbactimelockFilterer{contract: contract}}, nil
}

// NewRbactimelockCaller creates a new read-only instance of Rbactimelock, bound to a specific deployed contract.
func NewRbactimelockCaller(address common.Address, caller bind.ContractCaller) (*RbactimelockCaller, error) {
	contract, err := bindRbactimelock(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RbactimelockCaller{contract: contract}, nil
}

// NewRbactimelockTransactor creates a new write-only instance of Rbactimelock, bound to a specific deployed contract.
func NewRbactimelockTransactor(address common.Address, transactor bind.ContractTransactor) (*RbactimelockTransactor, error) {
	contract, err := bindRbactimelock(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RbactimelockTransactor{contract: contract}, nil
}

// NewRbactimelockFilterer creates a new log filterer instance of Rbactimelock, bound to a specific deployed contract.
func NewRbactimelockFilterer(address common.Address, filterer bind.ContractFilterer) (*RbactimelockFilterer, error) {
	contract, err := bindRbactimelock(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RbactimelockFilterer{contract: contract}, nil
}

// bindRbactimelock binds a generic wrapper to an already deployed contract.
func bindRbactimelock(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := RbactimelockMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Rbactimelock *RbactimelockRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Rbactimelock.Contract.RbactimelockCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Rbactimelock *RbactimelockRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RbactimelockTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Rbactimelock *RbactimelockRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RbactimelockTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Rbactimelock *RbactimelockCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Rbactimelock.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Rbactimelock *RbactimelockTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Rbactimelock.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Rbactimelock *RbactimelockTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Rbactimelock.Contract.contract.Transact(opts, method, params...)
}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) ADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) ADMINROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.ADMINROLE(&_Rbactimelock.CallOpts)
}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) ADMINROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.ADMINROLE(&_Rbactimelock.CallOpts)
}

// BYPASSERROLE is a free data retrieval call binding the contract method 0x191cb7b3.
//
// Solidity: function BYPASSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) BYPASSERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "BYPASSER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// BYPASSERROLE is a free data retrieval call binding the contract method 0x191cb7b3.
//
// Solidity: function BYPASSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) BYPASSERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.BYPASSERROLE(&_Rbactimelock.CallOpts)
}

// BYPASSERROLE is a free data retrieval call binding the contract method 0x191cb7b3.
//
// Solidity: function BYPASSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) BYPASSERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.BYPASSERROLE(&_Rbactimelock.CallOpts)
}

// CANCELLERROLE is a free data retrieval call binding the contract method 0xb08e51c0.
//
// Solidity: function CANCELLER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) CANCELLERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "CANCELLER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CANCELLERROLE is a free data retrieval call binding the contract method 0xb08e51c0.
//
// Solidity: function CANCELLER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) CANCELLERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.CANCELLERROLE(&_Rbactimelock.CallOpts)
}

// CANCELLERROLE is a free data retrieval call binding the contract method 0xb08e51c0.
//
// Solidity: function CANCELLER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) CANCELLERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.CANCELLERROLE(&_Rbactimelock.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.DEFAULTADMINROLE(&_Rbactimelock.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.DEFAULTADMINROLE(&_Rbactimelock.CallOpts)
}

// EXECUTORROLE is a free data retrieval call binding the contract method 0x07bd0265.
//
// Solidity: function EXECUTOR_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) EXECUTORROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "EXECUTOR_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// EXECUTORROLE is a free data retrieval call binding the contract method 0x07bd0265.
//
// Solidity: function EXECUTOR_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) EXECUTORROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.EXECUTORROLE(&_Rbactimelock.CallOpts)
}

// EXECUTORROLE is a free data retrieval call binding the contract method 0x07bd0265.
//
// Solidity: function EXECUTOR_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) EXECUTORROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.EXECUTORROLE(&_Rbactimelock.CallOpts)
}

// PROPOSERROLE is a free data retrieval call binding the contract method 0x8f61f4f5.
//
// Solidity: function PROPOSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) PROPOSERROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "PROPOSER_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// PROPOSERROLE is a free data retrieval call binding the contract method 0x8f61f4f5.
//
// Solidity: function PROPOSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) PROPOSERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.PROPOSERROLE(&_Rbactimelock.CallOpts)
}

// PROPOSERROLE is a free data retrieval call binding the contract method 0x8f61f4f5.
//
// Solidity: function PROPOSER_ROLE() view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) PROPOSERROLE() ([32]byte, error) {
	return _Rbactimelock.Contract.PROPOSERROLE(&_Rbactimelock.CallOpts)
}

// GetBlockedFunctionSelectorAt is a free data retrieval call binding the contract method 0x03e56155.
//
// Solidity: function getBlockedFunctionSelectorAt(uint256 index) view returns(bytes4)
func (_Rbactimelock *RbactimelockCaller) GetBlockedFunctionSelectorAt(opts *bind.CallOpts, index *big.Int) ([4]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getBlockedFunctionSelectorAt", index)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// GetBlockedFunctionSelectorAt is a free data retrieval call binding the contract method 0x03e56155.
//
// Solidity: function getBlockedFunctionSelectorAt(uint256 index) view returns(bytes4)
func (_Rbactimelock *RbactimelockSession) GetBlockedFunctionSelectorAt(index *big.Int) ([4]byte, error) {
	return _Rbactimelock.Contract.GetBlockedFunctionSelectorAt(&_Rbactimelock.CallOpts, index)
}

// GetBlockedFunctionSelectorAt is a free data retrieval call binding the contract method 0x03e56155.
//
// Solidity: function getBlockedFunctionSelectorAt(uint256 index) view returns(bytes4)
func (_Rbactimelock *RbactimelockCallerSession) GetBlockedFunctionSelectorAt(index *big.Int) ([4]byte, error) {
	return _Rbactimelock.Contract.GetBlockedFunctionSelectorAt(&_Rbactimelock.CallOpts, index)
}

// GetBlockedFunctionSelectorCount is a free data retrieval call binding the contract method 0x26bb2ec5.
//
// Solidity: function getBlockedFunctionSelectorCount() view returns(uint256)
func (_Rbactimelock *RbactimelockCaller) GetBlockedFunctionSelectorCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getBlockedFunctionSelectorCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetBlockedFunctionSelectorCount is a free data retrieval call binding the contract method 0x26bb2ec5.
//
// Solidity: function getBlockedFunctionSelectorCount() view returns(uint256)
func (_Rbactimelock *RbactimelockSession) GetBlockedFunctionSelectorCount() (*big.Int, error) {
	return _Rbactimelock.Contract.GetBlockedFunctionSelectorCount(&_Rbactimelock.CallOpts)
}

// GetBlockedFunctionSelectorCount is a free data retrieval call binding the contract method 0x26bb2ec5.
//
// Solidity: function getBlockedFunctionSelectorCount() view returns(uint256)
func (_Rbactimelock *RbactimelockCallerSession) GetBlockedFunctionSelectorCount() (*big.Int, error) {
	return _Rbactimelock.Contract.GetBlockedFunctionSelectorCount(&_Rbactimelock.CallOpts)
}

// GetMinDelay is a free data retrieval call binding the contract method 0xf27a0c92.
//
// Solidity: function getMinDelay() view returns(uint256 duration)
func (_Rbactimelock *RbactimelockCaller) GetMinDelay(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getMinDelay")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetMinDelay is a free data retrieval call binding the contract method 0xf27a0c92.
//
// Solidity: function getMinDelay() view returns(uint256 duration)
func (_Rbactimelock *RbactimelockSession) GetMinDelay() (*big.Int, error) {
	return _Rbactimelock.Contract.GetMinDelay(&_Rbactimelock.CallOpts)
}

// GetMinDelay is a free data retrieval call binding the contract method 0xf27a0c92.
//
// Solidity: function getMinDelay() view returns(uint256 duration)
func (_Rbactimelock *RbactimelockCallerSession) GetMinDelay() (*big.Int, error) {
	return _Rbactimelock.Contract.GetMinDelay(&_Rbactimelock.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Rbactimelock *RbactimelockCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Rbactimelock *RbactimelockSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _Rbactimelock.Contract.GetRoleAdmin(&_Rbactimelock.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Rbactimelock *RbactimelockCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _Rbactimelock.Contract.GetRoleAdmin(&_Rbactimelock.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Rbactimelock *RbactimelockCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Rbactimelock *RbactimelockSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _Rbactimelock.Contract.GetRoleMember(&_Rbactimelock.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Rbactimelock *RbactimelockCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _Rbactimelock.Contract.GetRoleMember(&_Rbactimelock.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Rbactimelock *RbactimelockCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Rbactimelock *RbactimelockSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _Rbactimelock.Contract.GetRoleMemberCount(&_Rbactimelock.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Rbactimelock *RbactimelockCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _Rbactimelock.Contract.GetRoleMemberCount(&_Rbactimelock.CallOpts, role)
}

// GetTimestamp is a free data retrieval call binding the contract method 0xd45c4435.
//
// Solidity: function getTimestamp(bytes32 id) view returns(uint256 timestamp)
func (_Rbactimelock *RbactimelockCaller) GetTimestamp(opts *bind.CallOpts, id [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "getTimestamp", id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetTimestamp is a free data retrieval call binding the contract method 0xd45c4435.
//
// Solidity: function getTimestamp(bytes32 id) view returns(uint256 timestamp)
func (_Rbactimelock *RbactimelockSession) GetTimestamp(id [32]byte) (*big.Int, error) {
	return _Rbactimelock.Contract.GetTimestamp(&_Rbactimelock.CallOpts, id)
}

// GetTimestamp is a free data retrieval call binding the contract method 0xd45c4435.
//
// Solidity: function getTimestamp(bytes32 id) view returns(uint256 timestamp)
func (_Rbactimelock *RbactimelockCallerSession) GetTimestamp(id [32]byte) (*big.Int, error) {
	return _Rbactimelock.Contract.GetTimestamp(&_Rbactimelock.CallOpts, id)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Rbactimelock *RbactimelockCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Rbactimelock *RbactimelockSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _Rbactimelock.Contract.HasRole(&_Rbactimelock.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Rbactimelock *RbactimelockCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _Rbactimelock.Contract.HasRole(&_Rbactimelock.CallOpts, role, account)
}

// HashOperationBatch is a free data retrieval call binding the contract method 0x515a3db3.
//
// Solidity: function hashOperationBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) pure returns(bytes32 hash)
func (_Rbactimelock *RbactimelockCaller) HashOperationBatch(opts *bind.CallOpts, calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "hashOperationBatch", calls, predecessor, salt)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// HashOperationBatch is a free data retrieval call binding the contract method 0x515a3db3.
//
// Solidity: function hashOperationBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) pure returns(bytes32 hash)
func (_Rbactimelock *RbactimelockSession) HashOperationBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) ([32]byte, error) {
	return _Rbactimelock.Contract.HashOperationBatch(&_Rbactimelock.CallOpts, calls, predecessor, salt)
}

// HashOperationBatch is a free data retrieval call binding the contract method 0x515a3db3.
//
// Solidity: function hashOperationBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) pure returns(bytes32 hash)
func (_Rbactimelock *RbactimelockCallerSession) HashOperationBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) ([32]byte, error) {
	return _Rbactimelock.Contract.HashOperationBatch(&_Rbactimelock.CallOpts, calls, predecessor, salt)
}

// IsOperation is a free data retrieval call binding the contract method 0x31d50750.
//
// Solidity: function isOperation(bytes32 id) view returns(bool registered)
func (_Rbactimelock *RbactimelockCaller) IsOperation(opts *bind.CallOpts, id [32]byte) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "isOperation", id)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsOperation is a free data retrieval call binding the contract method 0x31d50750.
//
// Solidity: function isOperation(bytes32 id) view returns(bool registered)
func (_Rbactimelock *RbactimelockSession) IsOperation(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperation(&_Rbactimelock.CallOpts, id)
}

// IsOperation is a free data retrieval call binding the contract method 0x31d50750.
//
// Solidity: function isOperation(bytes32 id) view returns(bool registered)
func (_Rbactimelock *RbactimelockCallerSession) IsOperation(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperation(&_Rbactimelock.CallOpts, id)
}

// IsOperationDone is a free data retrieval call binding the contract method 0x2ab0f529.
//
// Solidity: function isOperationDone(bytes32 id) view returns(bool done)
func (_Rbactimelock *RbactimelockCaller) IsOperationDone(opts *bind.CallOpts, id [32]byte) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "isOperationDone", id)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsOperationDone is a free data retrieval call binding the contract method 0x2ab0f529.
//
// Solidity: function isOperationDone(bytes32 id) view returns(bool done)
func (_Rbactimelock *RbactimelockSession) IsOperationDone(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationDone(&_Rbactimelock.CallOpts, id)
}

// IsOperationDone is a free data retrieval call binding the contract method 0x2ab0f529.
//
// Solidity: function isOperationDone(bytes32 id) view returns(bool done)
func (_Rbactimelock *RbactimelockCallerSession) IsOperationDone(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationDone(&_Rbactimelock.CallOpts, id)
}

// IsOperationPending is a free data retrieval call binding the contract method 0x584b153e.
//
// Solidity: function isOperationPending(bytes32 id) view returns(bool pending)
func (_Rbactimelock *RbactimelockCaller) IsOperationPending(opts *bind.CallOpts, id [32]byte) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "isOperationPending", id)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsOperationPending is a free data retrieval call binding the contract method 0x584b153e.
//
// Solidity: function isOperationPending(bytes32 id) view returns(bool pending)
func (_Rbactimelock *RbactimelockSession) IsOperationPending(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationPending(&_Rbactimelock.CallOpts, id)
}

// IsOperationPending is a free data retrieval call binding the contract method 0x584b153e.
//
// Solidity: function isOperationPending(bytes32 id) view returns(bool pending)
func (_Rbactimelock *RbactimelockCallerSession) IsOperationPending(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationPending(&_Rbactimelock.CallOpts, id)
}

// IsOperationReady is a free data retrieval call binding the contract method 0x13bc9f20.
//
// Solidity: function isOperationReady(bytes32 id) view returns(bool ready)
func (_Rbactimelock *RbactimelockCaller) IsOperationReady(opts *bind.CallOpts, id [32]byte) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "isOperationReady", id)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsOperationReady is a free data retrieval call binding the contract method 0x13bc9f20.
//
// Solidity: function isOperationReady(bytes32 id) view returns(bool ready)
func (_Rbactimelock *RbactimelockSession) IsOperationReady(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationReady(&_Rbactimelock.CallOpts, id)
}

// IsOperationReady is a free data retrieval call binding the contract method 0x13bc9f20.
//
// Solidity: function isOperationReady(bytes32 id) view returns(bool ready)
func (_Rbactimelock *RbactimelockCallerSession) IsOperationReady(id [32]byte) (bool, error) {
	return _Rbactimelock.Contract.IsOperationReady(&_Rbactimelock.CallOpts, id)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Rbactimelock *RbactimelockCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _Rbactimelock.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Rbactimelock *RbactimelockSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Rbactimelock.Contract.SupportsInterface(&_Rbactimelock.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Rbactimelock *RbactimelockCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Rbactimelock.Contract.SupportsInterface(&_Rbactimelock.CallOpts, interfaceId)
}

// BlockFunctionSelector is a paid mutator transaction binding the contract method 0x9f5a23f7.
//
// Solidity: function blockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockTransactor) BlockFunctionSelector(opts *bind.TransactOpts, selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "blockFunctionSelector", selector)
}

// BlockFunctionSelector is a paid mutator transaction binding the contract method 0x9f5a23f7.
//
// Solidity: function blockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockSession) BlockFunctionSelector(selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.BlockFunctionSelector(&_Rbactimelock.TransactOpts, selector)
}

// BlockFunctionSelector is a paid mutator transaction binding the contract method 0x9f5a23f7.
//
// Solidity: function blockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockTransactorSession) BlockFunctionSelector(selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.BlockFunctionSelector(&_Rbactimelock.TransactOpts, selector)
}

// BypasserExecuteBatch is a paid mutator transaction binding the contract method 0x0db866b1.
//
// Solidity: function bypasserExecuteBatch((address,uint256,bytes)[] calls) payable returns()
func (_Rbactimelock *RbactimelockTransactor) BypasserExecuteBatch(opts *bind.TransactOpts, calls []RBACTimelockCall) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "bypasserExecuteBatch", calls)
}

// BypasserExecuteBatch is a paid mutator transaction binding the contract method 0x0db866b1.
//
// Solidity: function bypasserExecuteBatch((address,uint256,bytes)[] calls) payable returns()
func (_Rbactimelock *RbactimelockSession) BypasserExecuteBatch(calls []RBACTimelockCall) (*types.Transaction, error) {
	return _Rbactimelock.Contract.BypasserExecuteBatch(&_Rbactimelock.TransactOpts, calls)
}

// BypasserExecuteBatch is a paid mutator transaction binding the contract method 0x0db866b1.
//
// Solidity: function bypasserExecuteBatch((address,uint256,bytes)[] calls) payable returns()
func (_Rbactimelock *RbactimelockTransactorSession) BypasserExecuteBatch(calls []RBACTimelockCall) (*types.Transaction, error) {
	return _Rbactimelock.Contract.BypasserExecuteBatch(&_Rbactimelock.TransactOpts, calls)
}

// Cancel is a paid mutator transaction binding the contract method 0xc4d252f5.
//
// Solidity: function cancel(bytes32 id) returns()
func (_Rbactimelock *RbactimelockTransactor) Cancel(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "cancel", id)
}

// Cancel is a paid mutator transaction binding the contract method 0xc4d252f5.
//
// Solidity: function cancel(bytes32 id) returns()
func (_Rbactimelock *RbactimelockSession) Cancel(id [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.Cancel(&_Rbactimelock.TransactOpts, id)
}

// Cancel is a paid mutator transaction binding the contract method 0xc4d252f5.
//
// Solidity: function cancel(bytes32 id) returns()
func (_Rbactimelock *RbactimelockTransactorSession) Cancel(id [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.Cancel(&_Rbactimelock.TransactOpts, id)
}

// ExecuteBatch is a paid mutator transaction binding the contract method 0x6ceef480.
//
// Solidity: function executeBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) payable returns()
func (_Rbactimelock *RbactimelockTransactor) ExecuteBatch(opts *bind.TransactOpts, calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "executeBatch", calls, predecessor, salt)
}

// ExecuteBatch is a paid mutator transaction binding the contract method 0x6ceef480.
//
// Solidity: function executeBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) payable returns()
func (_Rbactimelock *RbactimelockSession) ExecuteBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.ExecuteBatch(&_Rbactimelock.TransactOpts, calls, predecessor, salt)
}

// ExecuteBatch is a paid mutator transaction binding the contract method 0x6ceef480.
//
// Solidity: function executeBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt) payable returns()
func (_Rbactimelock *RbactimelockTransactorSession) ExecuteBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.ExecuteBatch(&_Rbactimelock.TransactOpts, calls, predecessor, salt)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.GrantRole(&_Rbactimelock.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.GrantRole(&_Rbactimelock.TransactOpts, role, account)
}

// OnERC1155BatchReceived is a paid mutator transaction binding the contract method 0xbc197c81.
//
// Solidity: function onERC1155BatchReceived(address , address , uint256[] , uint256[] , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactor) OnERC1155BatchReceived(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 []*big.Int, arg3 []*big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "onERC1155BatchReceived", arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155BatchReceived is a paid mutator transaction binding the contract method 0xbc197c81.
//
// Solidity: function onERC1155BatchReceived(address , address , uint256[] , uint256[] , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockSession) OnERC1155BatchReceived(arg0 common.Address, arg1 common.Address, arg2 []*big.Int, arg3 []*big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC1155BatchReceived(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155BatchReceived is a paid mutator transaction binding the contract method 0xbc197c81.
//
// Solidity: function onERC1155BatchReceived(address , address , uint256[] , uint256[] , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactorSession) OnERC1155BatchReceived(arg0 common.Address, arg1 common.Address, arg2 []*big.Int, arg3 []*big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC1155BatchReceived(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155Received is a paid mutator transaction binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactor) OnERC1155Received(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "onERC1155Received", arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155Received is a paid mutator transaction binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockSession) OnERC1155Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC1155Received(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155Received is a paid mutator transaction binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactorSession) OnERC1155Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC1155Received(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactor) OnERC721Received(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "onERC721Received", arg0, arg1, arg2, arg3)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC721Received(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) returns(bytes4)
func (_Rbactimelock *RbactimelockTransactorSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.OnERC721Received(&_Rbactimelock.TransactOpts, arg0, arg1, arg2, arg3)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RenounceRole(&_Rbactimelock.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RenounceRole(&_Rbactimelock.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RevokeRole(&_Rbactimelock.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Rbactimelock *RbactimelockTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Rbactimelock.Contract.RevokeRole(&_Rbactimelock.TransactOpts, role, account)
}

// ScheduleBatch is a paid mutator transaction binding the contract method 0xa944142d.
//
// Solidity: function scheduleBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt, uint256 delay) returns()
func (_Rbactimelock *RbactimelockTransactor) ScheduleBatch(opts *bind.TransactOpts, calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte, delay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "scheduleBatch", calls, predecessor, salt, delay)
}

// ScheduleBatch is a paid mutator transaction binding the contract method 0xa944142d.
//
// Solidity: function scheduleBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt, uint256 delay) returns()
func (_Rbactimelock *RbactimelockSession) ScheduleBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte, delay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.Contract.ScheduleBatch(&_Rbactimelock.TransactOpts, calls, predecessor, salt, delay)
}

// ScheduleBatch is a paid mutator transaction binding the contract method 0xa944142d.
//
// Solidity: function scheduleBatch((address,uint256,bytes)[] calls, bytes32 predecessor, bytes32 salt, uint256 delay) returns()
func (_Rbactimelock *RbactimelockTransactorSession) ScheduleBatch(calls []RBACTimelockCall, predecessor [32]byte, salt [32]byte, delay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.Contract.ScheduleBatch(&_Rbactimelock.TransactOpts, calls, predecessor, salt, delay)
}

// UnblockFunctionSelector is a paid mutator transaction binding the contract method 0x3a98b4e4.
//
// Solidity: function unblockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockTransactor) UnblockFunctionSelector(opts *bind.TransactOpts, selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "unblockFunctionSelector", selector)
}

// UnblockFunctionSelector is a paid mutator transaction binding the contract method 0x3a98b4e4.
//
// Solidity: function unblockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockSession) UnblockFunctionSelector(selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.UnblockFunctionSelector(&_Rbactimelock.TransactOpts, selector)
}

// UnblockFunctionSelector is a paid mutator transaction binding the contract method 0x3a98b4e4.
//
// Solidity: function unblockFunctionSelector(bytes4 selector) returns()
func (_Rbactimelock *RbactimelockTransactorSession) UnblockFunctionSelector(selector [4]byte) (*types.Transaction, error) {
	return _Rbactimelock.Contract.UnblockFunctionSelector(&_Rbactimelock.TransactOpts, selector)
}

// UpdateDelay is a paid mutator transaction binding the contract method 0x64d62353.
//
// Solidity: function updateDelay(uint256 newDelay) returns()
func (_Rbactimelock *RbactimelockTransactor) UpdateDelay(opts *bind.TransactOpts, newDelay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.contract.Transact(opts, "updateDelay", newDelay)
}

// UpdateDelay is a paid mutator transaction binding the contract method 0x64d62353.
//
// Solidity: function updateDelay(uint256 newDelay) returns()
func (_Rbactimelock *RbactimelockSession) UpdateDelay(newDelay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.Contract.UpdateDelay(&_Rbactimelock.TransactOpts, newDelay)
}

// UpdateDelay is a paid mutator transaction binding the contract method 0x64d62353.
//
// Solidity: function updateDelay(uint256 newDelay) returns()
func (_Rbactimelock *RbactimelockTransactorSession) UpdateDelay(newDelay *big.Int) (*types.Transaction, error) {
	return _Rbactimelock.Contract.UpdateDelay(&_Rbactimelock.TransactOpts, newDelay)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Rbactimelock *RbactimelockTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Rbactimelock.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Rbactimelock *RbactimelockSession) Receive() (*types.Transaction, error) {
	return _Rbactimelock.Contract.Receive(&_Rbactimelock.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Rbactimelock *RbactimelockTransactorSession) Receive() (*types.Transaction, error) {
	return _Rbactimelock.Contract.Receive(&_Rbactimelock.TransactOpts)
}

// RbactimelockBypasserCallExecutedIterator is returned from FilterBypasserCallExecuted and is used to iterate over the raw logs and unpacked data for BypasserCallExecuted events raised by the Rbactimelock contract.
type RbactimelockBypasserCallExecutedIterator struct {
	Event *RbactimelockBypasserCallExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockBypasserCallExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockBypasserCallExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockBypasserCallExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockBypasserCallExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockBypasserCallExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockBypasserCallExecuted represents a BypasserCallExecuted event raised by the Rbactimelock contract.
type RbactimelockBypasserCallExecuted struct {
	Index  *big.Int
	Target common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBypasserCallExecuted is a free log retrieval operation binding the contract event 0x6b983f337bab73dfe37faca733adf3ea35b45b8b144ec8ee2de3a1b224564b0c.
//
// Solidity: event BypasserCallExecuted(uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) FilterBypasserCallExecuted(opts *bind.FilterOpts, index []*big.Int) (*RbactimelockBypasserCallExecutedIterator, error) {

	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "BypasserCallExecuted", indexRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockBypasserCallExecutedIterator{contract: _Rbactimelock.contract, event: "BypasserCallExecuted", logs: logs, sub: sub}, nil
}

// WatchBypasserCallExecuted is a free log subscription operation binding the contract event 0x6b983f337bab73dfe37faca733adf3ea35b45b8b144ec8ee2de3a1b224564b0c.
//
// Solidity: event BypasserCallExecuted(uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) WatchBypasserCallExecuted(opts *bind.WatchOpts, sink chan<- *RbactimelockBypasserCallExecuted, index []*big.Int) (event.Subscription, error) {

	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "BypasserCallExecuted", indexRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockBypasserCallExecuted)
				if err := _Rbactimelock.contract.UnpackLog(event, "BypasserCallExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBypasserCallExecuted is a log parse operation binding the contract event 0x6b983f337bab73dfe37faca733adf3ea35b45b8b144ec8ee2de3a1b224564b0c.
//
// Solidity: event BypasserCallExecuted(uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) ParseBypasserCallExecuted(log types.Log) (*RbactimelockBypasserCallExecuted, error) {
	event := new(RbactimelockBypasserCallExecuted)
	if err := _Rbactimelock.contract.UnpackLog(event, "BypasserCallExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockCallExecutedIterator is returned from FilterCallExecuted and is used to iterate over the raw logs and unpacked data for CallExecuted events raised by the Rbactimelock contract.
type RbactimelockCallExecutedIterator struct {
	Event *RbactimelockCallExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockCallExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockCallExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockCallExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockCallExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockCallExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockCallExecuted represents a CallExecuted event raised by the Rbactimelock contract.
type RbactimelockCallExecuted struct {
	Id     [32]byte
	Index  *big.Int
	Target common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCallExecuted is a free log retrieval operation binding the contract event 0xc2617efa69bab66782fa219543714338489c4e9e178271560a91b82c3f612b58.
//
// Solidity: event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) FilterCallExecuted(opts *bind.FilterOpts, id [][32]byte, index []*big.Int) (*RbactimelockCallExecutedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "CallExecuted", idRule, indexRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockCallExecutedIterator{contract: _Rbactimelock.contract, event: "CallExecuted", logs: logs, sub: sub}, nil
}

// WatchCallExecuted is a free log subscription operation binding the contract event 0xc2617efa69bab66782fa219543714338489c4e9e178271560a91b82c3f612b58.
//
// Solidity: event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) WatchCallExecuted(opts *bind.WatchOpts, sink chan<- *RbactimelockCallExecuted, id [][32]byte, index []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "CallExecuted", idRule, indexRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockCallExecuted)
				if err := _Rbactimelock.contract.UnpackLog(event, "CallExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCallExecuted is a log parse operation binding the contract event 0xc2617efa69bab66782fa219543714338489c4e9e178271560a91b82c3f612b58.
//
// Solidity: event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data)
func (_Rbactimelock *RbactimelockFilterer) ParseCallExecuted(log types.Log) (*RbactimelockCallExecuted, error) {
	event := new(RbactimelockCallExecuted)
	if err := _Rbactimelock.contract.UnpackLog(event, "CallExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockCallScheduledIterator is returned from FilterCallScheduled and is used to iterate over the raw logs and unpacked data for CallScheduled events raised by the Rbactimelock contract.
type RbactimelockCallScheduledIterator struct {
	Event *RbactimelockCallScheduled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockCallScheduledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockCallScheduled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockCallScheduled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockCallScheduledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockCallScheduledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockCallScheduled represents a CallScheduled event raised by the Rbactimelock contract.
type RbactimelockCallScheduled struct {
	Id          [32]byte
	Index       *big.Int
	Target      common.Address
	Value       *big.Int
	Data        []byte
	Predecessor [32]byte
	Salt        [32]byte
	Delay       *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterCallScheduled is a free log retrieval operation binding the contract event 0x4f4da6666f52e3b6dbc3638d8eae4017722678fe58bca79cd8320817807a65be.
//
// Solidity: event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt, uint256 delay)
func (_Rbactimelock *RbactimelockFilterer) FilterCallScheduled(opts *bind.FilterOpts, id [][32]byte, index []*big.Int) (*RbactimelockCallScheduledIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "CallScheduled", idRule, indexRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockCallScheduledIterator{contract: _Rbactimelock.contract, event: "CallScheduled", logs: logs, sub: sub}, nil
}

// WatchCallScheduled is a free log subscription operation binding the contract event 0x4f4da6666f52e3b6dbc3638d8eae4017722678fe58bca79cd8320817807a65be.
//
// Solidity: event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt, uint256 delay)
func (_Rbactimelock *RbactimelockFilterer) WatchCallScheduled(opts *bind.WatchOpts, sink chan<- *RbactimelockCallScheduled, id [][32]byte, index []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var indexRule []interface{}
	for _, indexItem := range index {
		indexRule = append(indexRule, indexItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "CallScheduled", idRule, indexRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockCallScheduled)
				if err := _Rbactimelock.contract.UnpackLog(event, "CallScheduled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCallScheduled is a log parse operation binding the contract event 0x4f4da6666f52e3b6dbc3638d8eae4017722678fe58bca79cd8320817807a65be.
//
// Solidity: event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, bytes32 salt, uint256 delay)
func (_Rbactimelock *RbactimelockFilterer) ParseCallScheduled(log types.Log) (*RbactimelockCallScheduled, error) {
	event := new(RbactimelockCallScheduled)
	if err := _Rbactimelock.contract.UnpackLog(event, "CallScheduled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockCancelledIterator is returned from FilterCancelled and is used to iterate over the raw logs and unpacked data for Cancelled events raised by the Rbactimelock contract.
type RbactimelockCancelledIterator struct {
	Event *RbactimelockCancelled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockCancelledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockCancelled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockCancelled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockCancelledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockCancelledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockCancelled represents a Cancelled event raised by the Rbactimelock contract.
type RbactimelockCancelled struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterCancelled is a free log retrieval operation binding the contract event 0xbaa1eb22f2a492ba1a5fea61b8df4d27c6c8b5f3971e63bb58fa14ff72eedb70.
//
// Solidity: event Cancelled(bytes32 indexed id)
func (_Rbactimelock *RbactimelockFilterer) FilterCancelled(opts *bind.FilterOpts, id [][32]byte) (*RbactimelockCancelledIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "Cancelled", idRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockCancelledIterator{contract: _Rbactimelock.contract, event: "Cancelled", logs: logs, sub: sub}, nil
}

// WatchCancelled is a free log subscription operation binding the contract event 0xbaa1eb22f2a492ba1a5fea61b8df4d27c6c8b5f3971e63bb58fa14ff72eedb70.
//
// Solidity: event Cancelled(bytes32 indexed id)
func (_Rbactimelock *RbactimelockFilterer) WatchCancelled(opts *bind.WatchOpts, sink chan<- *RbactimelockCancelled, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "Cancelled", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockCancelled)
				if err := _Rbactimelock.contract.UnpackLog(event, "Cancelled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCancelled is a log parse operation binding the contract event 0xbaa1eb22f2a492ba1a5fea61b8df4d27c6c8b5f3971e63bb58fa14ff72eedb70.
//
// Solidity: event Cancelled(bytes32 indexed id)
func (_Rbactimelock *RbactimelockFilterer) ParseCancelled(log types.Log) (*RbactimelockCancelled, error) {
	event := new(RbactimelockCancelled)
	if err := _Rbactimelock.contract.UnpackLog(event, "Cancelled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockFunctionSelectorBlockedIterator is returned from FilterFunctionSelectorBlocked and is used to iterate over the raw logs and unpacked data for FunctionSelectorBlocked events raised by the Rbactimelock contract.
type RbactimelockFunctionSelectorBlockedIterator struct {
	Event *RbactimelockFunctionSelectorBlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockFunctionSelectorBlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockFunctionSelectorBlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockFunctionSelectorBlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockFunctionSelectorBlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockFunctionSelectorBlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockFunctionSelectorBlocked represents a FunctionSelectorBlocked event raised by the Rbactimelock contract.
type RbactimelockFunctionSelectorBlocked struct {
	Selector [4]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFunctionSelectorBlocked is a free log retrieval operation binding the contract event 0x15b40cf8ed4c95cd3c0e1dedfdb3987c3f9bf3d3770d13ddf6dc4daa5ffae9ef.
//
// Solidity: event FunctionSelectorBlocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) FilterFunctionSelectorBlocked(opts *bind.FilterOpts, selector [][4]byte) (*RbactimelockFunctionSelectorBlockedIterator, error) {

	var selectorRule []interface{}
	for _, selectorItem := range selector {
		selectorRule = append(selectorRule, selectorItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "FunctionSelectorBlocked", selectorRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockFunctionSelectorBlockedIterator{contract: _Rbactimelock.contract, event: "FunctionSelectorBlocked", logs: logs, sub: sub}, nil
}

// WatchFunctionSelectorBlocked is a free log subscription operation binding the contract event 0x15b40cf8ed4c95cd3c0e1dedfdb3987c3f9bf3d3770d13ddf6dc4daa5ffae9ef.
//
// Solidity: event FunctionSelectorBlocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) WatchFunctionSelectorBlocked(opts *bind.WatchOpts, sink chan<- *RbactimelockFunctionSelectorBlocked, selector [][4]byte) (event.Subscription, error) {

	var selectorRule []interface{}
	for _, selectorItem := range selector {
		selectorRule = append(selectorRule, selectorItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "FunctionSelectorBlocked", selectorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockFunctionSelectorBlocked)
				if err := _Rbactimelock.contract.UnpackLog(event, "FunctionSelectorBlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFunctionSelectorBlocked is a log parse operation binding the contract event 0x15b40cf8ed4c95cd3c0e1dedfdb3987c3f9bf3d3770d13ddf6dc4daa5ffae9ef.
//
// Solidity: event FunctionSelectorBlocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) ParseFunctionSelectorBlocked(log types.Log) (*RbactimelockFunctionSelectorBlocked, error) {
	event := new(RbactimelockFunctionSelectorBlocked)
	if err := _Rbactimelock.contract.UnpackLog(event, "FunctionSelectorBlocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockFunctionSelectorUnblockedIterator is returned from FilterFunctionSelectorUnblocked and is used to iterate over the raw logs and unpacked data for FunctionSelectorUnblocked events raised by the Rbactimelock contract.
type RbactimelockFunctionSelectorUnblockedIterator struct {
	Event *RbactimelockFunctionSelectorUnblocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockFunctionSelectorUnblockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockFunctionSelectorUnblocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockFunctionSelectorUnblocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockFunctionSelectorUnblockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockFunctionSelectorUnblockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockFunctionSelectorUnblocked represents a FunctionSelectorUnblocked event raised by the Rbactimelock contract.
type RbactimelockFunctionSelectorUnblocked struct {
	Selector [4]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFunctionSelectorUnblocked is a free log retrieval operation binding the contract event 0xd91859a8d88193a56a2983deb65a5253985141c49c70bf016880b5243bd432e1.
//
// Solidity: event FunctionSelectorUnblocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) FilterFunctionSelectorUnblocked(opts *bind.FilterOpts, selector [][4]byte) (*RbactimelockFunctionSelectorUnblockedIterator, error) {

	var selectorRule []interface{}
	for _, selectorItem := range selector {
		selectorRule = append(selectorRule, selectorItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "FunctionSelectorUnblocked", selectorRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockFunctionSelectorUnblockedIterator{contract: _Rbactimelock.contract, event: "FunctionSelectorUnblocked", logs: logs, sub: sub}, nil
}

// WatchFunctionSelectorUnblocked is a free log subscription operation binding the contract event 0xd91859a8d88193a56a2983deb65a5253985141c49c70bf016880b5243bd432e1.
//
// Solidity: event FunctionSelectorUnblocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) WatchFunctionSelectorUnblocked(opts *bind.WatchOpts, sink chan<- *RbactimelockFunctionSelectorUnblocked, selector [][4]byte) (event.Subscription, error) {

	var selectorRule []interface{}
	for _, selectorItem := range selector {
		selectorRule = append(selectorRule, selectorItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "FunctionSelectorUnblocked", selectorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockFunctionSelectorUnblocked)
				if err := _Rbactimelock.contract.UnpackLog(event, "FunctionSelectorUnblocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFunctionSelectorUnblocked is a log parse operation binding the contract event 0xd91859a8d88193a56a2983deb65a5253985141c49c70bf016880b5243bd432e1.
//
// Solidity: event FunctionSelectorUnblocked(bytes4 indexed selector)
func (_Rbactimelock *RbactimelockFilterer) ParseFunctionSelectorUnblocked(log types.Log) (*RbactimelockFunctionSelectorUnblocked, error) {
	event := new(RbactimelockFunctionSelectorUnblocked)
	if err := _Rbactimelock.contract.UnpackLog(event, "FunctionSelectorUnblocked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockMinDelayChangeIterator is returned from FilterMinDelayChange and is used to iterate over the raw logs and unpacked data for MinDelayChange events raised by the Rbactimelock contract.
type RbactimelockMinDelayChangeIterator struct {
	Event *RbactimelockMinDelayChange // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockMinDelayChangeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockMinDelayChange)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockMinDelayChange)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockMinDelayChangeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockMinDelayChangeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockMinDelayChange represents a MinDelayChange event raised by the Rbactimelock contract.
type RbactimelockMinDelayChange struct {
	OldDuration *big.Int
	NewDuration *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterMinDelayChange is a free log retrieval operation binding the contract event 0x11c24f4ead16507c69ac467fbd5e4eed5fb5c699626d2cc6d66421df253886d5.
//
// Solidity: event MinDelayChange(uint256 oldDuration, uint256 newDuration)
func (_Rbactimelock *RbactimelockFilterer) FilterMinDelayChange(opts *bind.FilterOpts) (*RbactimelockMinDelayChangeIterator, error) {

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "MinDelayChange")
	if err != nil {
		return nil, err
	}
	return &RbactimelockMinDelayChangeIterator{contract: _Rbactimelock.contract, event: "MinDelayChange", logs: logs, sub: sub}, nil
}

// WatchMinDelayChange is a free log subscription operation binding the contract event 0x11c24f4ead16507c69ac467fbd5e4eed5fb5c699626d2cc6d66421df253886d5.
//
// Solidity: event MinDelayChange(uint256 oldDuration, uint256 newDuration)
func (_Rbactimelock *RbactimelockFilterer) WatchMinDelayChange(opts *bind.WatchOpts, sink chan<- *RbactimelockMinDelayChange) (event.Subscription, error) {

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "MinDelayChange")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockMinDelayChange)
				if err := _Rbactimelock.contract.UnpackLog(event, "MinDelayChange", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDelayChange is a log parse operation binding the contract event 0x11c24f4ead16507c69ac467fbd5e4eed5fb5c699626d2cc6d66421df253886d5.
//
// Solidity: event MinDelayChange(uint256 oldDuration, uint256 newDuration)
func (_Rbactimelock *RbactimelockFilterer) ParseMinDelayChange(log types.Log) (*RbactimelockMinDelayChange, error) {
	event := new(RbactimelockMinDelayChange)
	if err := _Rbactimelock.contract.UnpackLog(event, "MinDelayChange", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the Rbactimelock contract.
type RbactimelockRoleAdminChangedIterator struct {
	Event *RbactimelockRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockRoleAdminChanged represents a RoleAdminChanged event raised by the Rbactimelock contract.
type RbactimelockRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Rbactimelock *RbactimelockFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*RbactimelockRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockRoleAdminChangedIterator{contract: _Rbactimelock.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Rbactimelock *RbactimelockFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *RbactimelockRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockRoleAdminChanged)
				if err := _Rbactimelock.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Rbactimelock *RbactimelockFilterer) ParseRoleAdminChanged(log types.Log) (*RbactimelockRoleAdminChanged, error) {
	event := new(RbactimelockRoleAdminChanged)
	if err := _Rbactimelock.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the Rbactimelock contract.
type RbactimelockRoleGrantedIterator struct {
	Event *RbactimelockRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockRoleGranted represents a RoleGranted event raised by the Rbactimelock contract.
type RbactimelockRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*RbactimelockRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockRoleGrantedIterator{contract: _Rbactimelock.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *RbactimelockRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockRoleGranted)
				if err := _Rbactimelock.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) ParseRoleGranted(log types.Log) (*RbactimelockRoleGranted, error) {
	event := new(RbactimelockRoleGranted)
	if err := _Rbactimelock.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RbactimelockRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the Rbactimelock contract.
type RbactimelockRoleRevokedIterator struct {
	Event *RbactimelockRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RbactimelockRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RbactimelockRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RbactimelockRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RbactimelockRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RbactimelockRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RbactimelockRoleRevoked represents a RoleRevoked event raised by the Rbactimelock contract.
type RbactimelockRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*RbactimelockRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Rbactimelock.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &RbactimelockRoleRevokedIterator{contract: _Rbactimelock.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *RbactimelockRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Rbactimelock.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RbactimelockRoleRevoked)
				if err := _Rbactimelock.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Rbactimelock *RbactimelockFilterer) ParseRoleRevoked(log types.Log) (*RbactimelockRoleRevoked, error) {
	event := new(RbactimelockRoleRevoked)
	if err := _Rbactimelock.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
