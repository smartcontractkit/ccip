// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	context "context"

	cciptypes "github.com/smartcontractkit/chainlink/v2/core/services/ocr2/plugins/ccip/cciptypes"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// CommitStoreReader is an autogenerated mock type for the CommitStoreReader type
type CommitStoreReader struct {
	mock.Mock
}

// ChangeConfig provides a mock function with given fields: onchainConfig, offchainConfig
func (_m *CommitStoreReader) ChangeConfig(onchainConfig []byte, offchainConfig []byte) (cciptypes.Address, error) {
	ret := _m.Called(onchainConfig, offchainConfig)

	if len(ret) == 0 {
		panic("no return value specified for ChangeConfig")
	}

	var r0 cciptypes.Address
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (cciptypes.Address, error)); ok {
		return rf(onchainConfig, offchainConfig)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) cciptypes.Address); ok {
		r0 = rf(onchainConfig, offchainConfig)
	} else {
		r0 = ret.Get(0).(cciptypes.Address)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(onchainConfig, offchainConfig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeCommitReport provides a mock function with given fields: report
func (_m *CommitStoreReader) DecodeCommitReport(report []byte) (cciptypes.CommitStoreReport, error) {
	ret := _m.Called(report)

	if len(ret) == 0 {
		panic("no return value specified for DecodeCommitReport")
	}

	var r0 cciptypes.CommitStoreReport
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (cciptypes.CommitStoreReport, error)); ok {
		return rf(report)
	}
	if rf, ok := ret.Get(0).(func([]byte) cciptypes.CommitStoreReport); ok {
		r0 = rf(report)
	} else {
		r0 = ret.Get(0).(cciptypes.CommitStoreReport)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncodeCommitReport provides a mock function with given fields: report
func (_m *CommitStoreReader) EncodeCommitReport(report cciptypes.CommitStoreReport) ([]byte, error) {
	ret := _m.Called(report)

	if len(ret) == 0 {
		panic("no return value specified for EncodeCommitReport")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(cciptypes.CommitStoreReport) ([]byte, error)); ok {
		return rf(report)
	}
	if rf, ok := ret.Get(0).(func(cciptypes.CommitStoreReport) []byte); ok {
		r0 = rf(report)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(cciptypes.CommitStoreReport) error); ok {
		r1 = rf(report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasPriceEstimator provides a mock function with given fields:
func (_m *CommitStoreReader) GasPriceEstimator() cciptypes.GasPriceEstimatorCommit {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GasPriceEstimator")
	}

	var r0 cciptypes.GasPriceEstimatorCommit
	if rf, ok := ret.Get(0).(func() cciptypes.GasPriceEstimatorCommit); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cciptypes.GasPriceEstimatorCommit)
		}
	}

	return r0
}

// GetAcceptedCommitReportsGteTimestamp provides a mock function with given fields: ctx, ts, confirmations
func (_m *CommitStoreReader) GetAcceptedCommitReportsGteTimestamp(ctx context.Context, ts time.Time, confirmations int) ([]cciptypes.CommitStoreReportWithTxMeta, error) {
	ret := _m.Called(ctx, ts, confirmations)

	if len(ret) == 0 {
		panic("no return value specified for GetAcceptedCommitReportsGteTimestamp")
	}

	var r0 []cciptypes.CommitStoreReportWithTxMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, int) ([]cciptypes.CommitStoreReportWithTxMeta, error)); ok {
		return rf(ctx, ts, confirmations)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, int) []cciptypes.CommitStoreReportWithTxMeta); ok {
		r0 = rf(ctx, ts, confirmations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cciptypes.CommitStoreReportWithTxMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time, int) error); ok {
		r1 = rf(ctx, ts, confirmations)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitReportMatchingSeqNum provides a mock function with given fields: ctx, seqNum, confirmations
func (_m *CommitStoreReader) GetCommitReportMatchingSeqNum(ctx context.Context, seqNum uint64, confirmations int) ([]cciptypes.CommitStoreReportWithTxMeta, error) {
	ret := _m.Called(ctx, seqNum, confirmations)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitReportMatchingSeqNum")
	}

	var r0 []cciptypes.CommitStoreReportWithTxMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, int) ([]cciptypes.CommitStoreReportWithTxMeta, error)); ok {
		return rf(ctx, seqNum, confirmations)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, int) []cciptypes.CommitStoreReportWithTxMeta); ok {
		r0 = rf(ctx, seqNum, confirmations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cciptypes.CommitStoreReportWithTxMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, int) error); ok {
		r1 = rf(ctx, seqNum, confirmations)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitStoreStaticConfig provides a mock function with given fields: ctx
func (_m *CommitStoreReader) GetCommitStoreStaticConfig(ctx context.Context) (cciptypes.CommitStoreStaticConfig, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitStoreStaticConfig")
	}

	var r0 cciptypes.CommitStoreStaticConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (cciptypes.CommitStoreStaticConfig, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) cciptypes.CommitStoreStaticConfig); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(cciptypes.CommitStoreStaticConfig)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExpectedNextSequenceNumber provides a mock function with given fields: _a0
func (_m *CommitStoreReader) GetExpectedNextSequenceNumber(_a0 context.Context) (uint64, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetExpectedNextSequenceNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPriceEpochAndRound provides a mock function with given fields: _a0
func (_m *CommitStoreReader) GetLatestPriceEpochAndRound(_a0 context.Context) (uint64, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPriceEpochAndRound")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsBlessed provides a mock function with given fields: ctx, root
func (_m *CommitStoreReader) IsBlessed(ctx context.Context, root [32]byte) (bool, error) {
	ret := _m.Called(ctx, root)

	if len(ret) == 0 {
		panic("no return value specified for IsBlessed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) (bool, error)); ok {
		return rf(ctx, root)
	}
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) bool); ok {
		r0 = rf(ctx, root)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, [32]byte) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsDown provides a mock function with given fields: ctx
func (_m *CommitStoreReader) IsDown(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsDown")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OffchainConfig provides a mock function with given fields:
func (_m *CommitStoreReader) OffchainConfig() cciptypes.CommitOffchainConfig {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OffchainConfig")
	}

	var r0 cciptypes.CommitOffchainConfig
	if rf, ok := ret.Get(0).(func() cciptypes.CommitOffchainConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(cciptypes.CommitOffchainConfig)
	}

	return r0
}

// VerifyExecutionReport provides a mock function with given fields: ctx, report
func (_m *CommitStoreReader) VerifyExecutionReport(ctx context.Context, report cciptypes.ExecReport) (bool, error) {
	ret := _m.Called(ctx, report)

	if len(ret) == 0 {
		panic("no return value specified for VerifyExecutionReport")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cciptypes.ExecReport) (bool, error)); ok {
		return rf(ctx, report)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cciptypes.ExecReport) bool); ok {
		r0 = rf(ctx, report)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cciptypes.ExecReport) error); ok {
		r1 = rf(ctx, report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCommitStoreReader creates a new instance of CommitStoreReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommitStoreReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommitStoreReader {
	mock := &CommitStoreReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
