// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	ccip "github.com/smartcontractkit/chainlink-common/pkg/types/ccip"

	context "context"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// CommitStoreReader is an autogenerated mock type for the CommitStoreReader type
type CommitStoreReader struct {
	mock.Mock
}

// ChangeConfig provides a mock function with given fields: ctx, onchainConfig, offchainConfig
func (_m *CommitStoreReader) ChangeConfig(ctx context.Context, onchainConfig []byte, offchainConfig []byte) (ccip.Address, error) {
	ret := _m.Called(ctx, onchainConfig, offchainConfig)

	if len(ret) == 0 {
		panic("no return value specified for ChangeConfig")
	}

	var r0 ccip.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) (ccip.Address, error)); ok {
		return rf(ctx, onchainConfig, offchainConfig)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) ccip.Address); ok {
		r0 = rf(ctx, onchainConfig, offchainConfig)
	} else {
		r0 = ret.Get(0).(ccip.Address)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, onchainConfig, offchainConfig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *CommitStoreReader) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DecodeCommitReport provides a mock function with given fields: ctx, report
func (_m *CommitStoreReader) DecodeCommitReport(ctx context.Context, report []byte) (ccip.CommitStoreReport, error) {
	ret := _m.Called(ctx, report)

	if len(ret) == 0 {
		panic("no return value specified for DecodeCommitReport")
	}

	var r0 ccip.CommitStoreReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) (ccip.CommitStoreReport, error)); ok {
		return rf(ctx, report)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte) ccip.CommitStoreReport); ok {
		r0 = rf(ctx, report)
	} else {
		r0 = ret.Get(0).(ccip.CommitStoreReport)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncodeCommitReport provides a mock function with given fields: ctx, report
func (_m *CommitStoreReader) EncodeCommitReport(ctx context.Context, report ccip.CommitStoreReport) ([]byte, error) {
	ret := _m.Called(ctx, report)

	if len(ret) == 0 {
		panic("no return value specified for EncodeCommitReport")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccip.CommitStoreReport) ([]byte, error)); ok {
		return rf(ctx, report)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccip.CommitStoreReport) []byte); ok {
		r0 = rf(ctx, report)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccip.CommitStoreReport) error); ok {
		r1 = rf(ctx, report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GasPriceEstimator provides a mock function with given fields: ctx
func (_m *CommitStoreReader) GasPriceEstimator(ctx context.Context) (ccip.GasPriceEstimatorCommit, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GasPriceEstimator")
	}

	var r0 ccip.GasPriceEstimatorCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccip.GasPriceEstimatorCommit, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccip.GasPriceEstimatorCommit); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ccip.GasPriceEstimatorCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAcceptedCommitReportsGteTimestamp provides a mock function with given fields: ctx, ts, confirmations
func (_m *CommitStoreReader) GetAcceptedCommitReportsGteTimestamp(ctx context.Context, ts time.Time, confirmations int) ([]ccip.CommitStoreReportWithTxMeta, error) {
	ret := _m.Called(ctx, ts, confirmations)

	if len(ret) == 0 {
		panic("no return value specified for GetAcceptedCommitReportsGteTimestamp")
	}

	var r0 []ccip.CommitStoreReportWithTxMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, int) ([]ccip.CommitStoreReportWithTxMeta, error)); ok {
		return rf(ctx, ts, confirmations)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, int) []ccip.CommitStoreReportWithTxMeta); ok {
		r0 = rf(ctx, ts, confirmations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ccip.CommitStoreReportWithTxMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time, int) error); ok {
		r1 = rf(ctx, ts, confirmations)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitReportMatchingSeqNum provides a mock function with given fields: ctx, seqNum, confirmations
func (_m *CommitStoreReader) GetCommitReportMatchingSeqNum(ctx context.Context, seqNum uint64, confirmations int) ([]ccip.CommitStoreReportWithTxMeta, error) {
	ret := _m.Called(ctx, seqNum, confirmations)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitReportMatchingSeqNum")
	}

	var r0 []ccip.CommitStoreReportWithTxMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, int) ([]ccip.CommitStoreReportWithTxMeta, error)); ok {
		return rf(ctx, seqNum, confirmations)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, int) []ccip.CommitStoreReportWithTxMeta); ok {
		r0 = rf(ctx, seqNum, confirmations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ccip.CommitStoreReportWithTxMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, int) error); ok {
		r1 = rf(ctx, seqNum, confirmations)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitStoreStaticConfig provides a mock function with given fields: ctx
func (_m *CommitStoreReader) GetCommitStoreStaticConfig(ctx context.Context) (ccip.CommitStoreStaticConfig, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitStoreStaticConfig")
	}

	var r0 ccip.CommitStoreStaticConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccip.CommitStoreStaticConfig, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccip.CommitStoreStaticConfig); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ccip.CommitStoreStaticConfig)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExpectedNextSequenceNumber provides a mock function with given fields: ctx
func (_m *CommitStoreReader) GetExpectedNextSequenceNumber(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetExpectedNextSequenceNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPriceEpochAndRound provides a mock function with given fields: ctx
func (_m *CommitStoreReader) GetLatestPriceEpochAndRound(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPriceEpochAndRound")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsBlessed provides a mock function with given fields: ctx, root
func (_m *CommitStoreReader) IsBlessed(ctx context.Context, root [32]byte) (bool, error) {
	ret := _m.Called(ctx, root)

	if len(ret) == 0 {
		panic("no return value specified for IsBlessed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) (bool, error)); ok {
		return rf(ctx, root)
	}
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) bool); ok {
		r0 = rf(ctx, root)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, [32]byte) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsDestChainHealthy provides a mock function with given fields: ctx
func (_m *CommitStoreReader) IsDestChainHealthy(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsDestChainHealthy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsDown provides a mock function with given fields: ctx
func (_m *CommitStoreReader) IsDown(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsDown")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OffchainConfig provides a mock function with given fields: ctx
func (_m *CommitStoreReader) OffchainConfig(ctx context.Context) (ccip.CommitOffchainConfig, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for OffchainConfig")
	}

	var r0 ccip.CommitOffchainConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (ccip.CommitOffchainConfig, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) ccip.CommitOffchainConfig); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(ccip.CommitOffchainConfig)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyExecutionReport provides a mock function with given fields: ctx, report
func (_m *CommitStoreReader) VerifyExecutionReport(ctx context.Context, report ccip.ExecReport) (bool, error) {
	ret := _m.Called(ctx, report)

	if len(ret) == 0 {
		panic("no return value specified for VerifyExecutionReport")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ccip.ExecReport) (bool, error)); ok {
		return rf(ctx, report)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ccip.ExecReport) bool); ok {
		r0 = rf(ctx, report)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ccip.ExecReport) error); ok {
		r1 = rf(ctx, report)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCommitStoreReader creates a new instance of CommitStoreReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommitStoreReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommitStoreReader {
	mock := &CommitStoreReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
